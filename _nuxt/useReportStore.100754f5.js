var we=Object.defineProperty;var ge=(s,t,e)=>t in s?we(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var se=(s,t,e)=>(ge(s,typeof t!="symbol"?t+"":t,e),e),te=(s,t,e)=>{if(!t.has(s))throw TypeError("Cannot "+e)};var r=(s,t,e)=>(te(s,t,"read from private field"),e?e.call(s):t.get(s)),f=(s,t,e)=>{if(t.has(s))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(s):t.set(s,e)},v=(s,t,e,n)=>(te(s,t,"write to private field"),n?n.call(s,e):t.set(s,e),e);var G=(s,t,e,n)=>({set _(l){v(s,t,l,e)},get _(){return r(s,t,n)}}),g=(s,t,e)=>(te(s,t,"access private method"),e);import{al as be,am as Ee,ai as Ie,D as xe,r as ie,ak as ae,v as Ce}from"./entry.bc979787.js";const _e=be(),Te=()=>_e,Pe=new AbortController,Oe=()=>Pe;var ce={exports:{}};(function(s){var t=Object.prototype.hasOwnProperty,e="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(e=!1));function l(c,a,i){this.fn=c,this.context=a,this.once=i||!1}function w(c,a,i,u,d){if(typeof i!="function")throw new TypeError("The listener must be a function");var b=new l(i,u||c,d),m=e?e+a:a;return c._events[m]?c._events[m].fn?c._events[m]=[c._events[m],b]:c._events[m].push(b):(c._events[m]=b,c._eventsCount++),c}function p(c,a){--c._eventsCount===0?c._events=new n:delete c._events[a]}function h(){this._events=new n,this._eventsCount=0}h.prototype.eventNames=function(){var a=[],i,u;if(this._eventsCount===0)return a;for(u in i=this._events)t.call(i,u)&&a.push(e?u.slice(1):u);return Object.getOwnPropertySymbols?a.concat(Object.getOwnPropertySymbols(i)):a},h.prototype.listeners=function(a){var i=e?e+a:a,u=this._events[i];if(!u)return[];if(u.fn)return[u.fn];for(var d=0,b=u.length,m=new Array(b);d<b;d++)m[d]=u[d].fn;return m},h.prototype.listenerCount=function(a){var i=e?e+a:a,u=this._events[i];return u?u.fn?1:u.length:0},h.prototype.emit=function(a,i,u,d,b,m){var _=e?e+a:a;if(!this._events[_])return!1;var o=this._events[_],P=arguments.length,A,y;if(o.fn){switch(o.once&&this.removeListener(a,o.fn,void 0,!0),P){case 1:return o.fn.call(o.context),!0;case 2:return o.fn.call(o.context,i),!0;case 3:return o.fn.call(o.context,i,u),!0;case 4:return o.fn.call(o.context,i,u,d),!0;case 5:return o.fn.call(o.context,i,u,d,b),!0;case 6:return o.fn.call(o.context,i,u,d,b,m),!0}for(y=1,A=new Array(P-1);y<P;y++)A[y-1]=arguments[y];o.fn.apply(o.context,A)}else{var ye=o.length,F;for(y=0;y<ye;y++)switch(o[y].once&&this.removeListener(a,o[y].fn,void 0,!0),P){case 1:o[y].fn.call(o[y].context);break;case 2:o[y].fn.call(o[y].context,i);break;case 3:o[y].fn.call(o[y].context,i,u);break;case 4:o[y].fn.call(o[y].context,i,u,d);break;default:if(!A)for(F=1,A=new Array(P-1);F<P;F++)A[F-1]=arguments[F];o[y].fn.apply(o[y].context,A)}}return!0},h.prototype.on=function(a,i,u){return w(this,a,i,u,!1)},h.prototype.once=function(a,i,u){return w(this,a,i,u,!0)},h.prototype.removeListener=function(a,i,u,d){var b=e?e+a:a;if(!this._events[b])return this;if(!i)return p(this,b),this;var m=this._events[b];if(m.fn)m.fn===i&&(!d||m.once)&&(!u||m.context===u)&&p(this,b);else{for(var _=0,o=[],P=m.length;_<P;_++)(m[_].fn!==i||d&&!m[_].once||u&&m[_].context!==u)&&o.push(m[_]);o.length?this._events[b]=o.length===1?o[0]:o:p(this,b)}return this},h.prototype.removeAllListeners=function(a){var i;return a?(i=e?e+a:a,this._events[i]&&p(this,i)):(this._events=new n,this._eventsCount=0),this},h.prototype.off=h.prototype.removeListener,h.prototype.addListener=h.prototype.on,h.prefixed=e,h.EventEmitter=h,s.exports=h})(ce);var Ae=ce.exports;const Ne=Ee(Ae);class le extends Error{constructor(t){super(t),this.name="TimeoutError"}}class Se extends Error{constructor(t){super(),this.name="AbortError",this.message=t}}const oe=s=>globalThis.DOMException===void 0?new Se(s):new DOMException(s),ue=s=>{const t=s.reason===void 0?oe("This operation was aborted."):s.reason;return t instanceof Error?t:oe(t)};function ze(s,t){const{milliseconds:e,fallback:n,message:l,customTimers:w={setTimeout,clearTimeout}}=t;let p;const c=new Promise((a,i)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(t.signal){const{signal:d}=t;d.aborted&&i(ue(d)),d.addEventListener("abort",()=>{i(ue(d))})}if(e===Number.POSITIVE_INFINITY){s.then(a,i);return}const u=new le;p=w.setTimeout.call(void 0,()=>{if(n){try{a(n())}catch(d){i(d)}return}typeof s.cancel=="function"&&s.cancel(),l===!1?a():l instanceof Error?i(l):(u.message=l??`Promise timed out after ${e} milliseconds`,i(u))},e),(async()=>{try{a(await s)}catch(d){i(d)}})()}).finally(()=>{c.clear()});return c.clear=()=>{w.clearTimeout.call(void 0,p),p=void 0},c}function Le(s,t,e){let n=0,l=s.length;for(;l>0;){const w=Math.trunc(l/2);let p=n+w;e(s[p],t)<=0?(n=++p,l-=w+1):l=w}return n}var C;class qe{constructor(){f(this,C,[])}enqueue(t,e){e={priority:0,...e};const n={priority:e.priority,run:t};if(this.size&&r(this,C)[this.size-1].priority>=e.priority){r(this,C).push(n);return}const l=Le(r(this,C),n,(w,p)=>p.priority-w.priority);r(this,C).splice(l,0,n)}dequeue(){const t=r(this,C).shift();return t==null?void 0:t.run}filter(t){return r(this,C).filter(e=>e.priority===t.priority).map(e=>e.run)}get size(){return r(this,C).length}}C=new WeakMap;var N,S,O,R,z,M,I,L,E,V,x,q,T,Y,U,he,W,fe,X,de,Z,ve,j,me,D,H,Q,re,B,ne,$,J,ee,pe,k,K;class De extends Ne{constructor(e){var n,l;super();f(this,U);f(this,W);f(this,X);f(this,Z);f(this,j);f(this,D);f(this,Q);f(this,B);f(this,$);f(this,ee);f(this,k);f(this,N,void 0);f(this,S,void 0);f(this,O,0);f(this,R,void 0);f(this,z,void 0);f(this,M,0);f(this,I,void 0);f(this,L,void 0);f(this,E,void 0);f(this,V,void 0);f(this,x,0);f(this,q,void 0);f(this,T,void 0);f(this,Y,void 0);se(this,"timeout");if(e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:qe,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((n=e.intervalCap)==null?void 0:n.toString())??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((l=e.interval)==null?void 0:l.toString())??""}\` (${typeof e.interval})`);v(this,N,e.carryoverConcurrencyCount),v(this,S,e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0),v(this,R,e.intervalCap),v(this,z,e.interval),v(this,E,new e.queueClass),v(this,V,e.queueClass),this.concurrency=e.concurrency,this.timeout=e.timeout,v(this,Y,e.throwOnTimeout===!0),v(this,T,e.autoStart===!1)}get concurrency(){return r(this,q)}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);v(this,q,e),g(this,$,J).call(this)}async add(e,n={}){return n={timeout:this.timeout,throwOnTimeout:r(this,Y),...n},new Promise((l,w)=>{r(this,E).enqueue(async()=>{var p;G(this,x)._++,G(this,O)._++;try{(p=n.signal)==null||p.throwIfAborted();let h=e({signal:n.signal});n.timeout&&(h=ze(Promise.resolve(h),{milliseconds:n.timeout})),n.signal&&(h=Promise.race([h,g(this,ee,pe).call(this,n.signal)]));const c=await h;l(c),this.emit("completed",c)}catch(h){if(h instanceof le&&!n.throwOnTimeout){l();return}w(h),this.emit("error",h)}finally{g(this,X,de).call(this)}},n),this.emit("add"),g(this,D,H).call(this)})}async addAll(e,n){return Promise.all(e.map(async l=>this.add(l,n)))}start(){return r(this,T)?(v(this,T,!1),g(this,$,J).call(this),this):this}pause(){v(this,T,!0)}clear(){v(this,E,new(r(this,V)))}async onEmpty(){r(this,E).size!==0&&await g(this,k,K).call(this,"empty")}async onSizeLessThan(e){r(this,E).size<e||await g(this,k,K).call(this,"next",()=>r(this,E).size<e)}async onIdle(){r(this,x)===0&&r(this,E).size===0||await g(this,k,K).call(this,"idle")}get size(){return r(this,E).size}sizeBy(e){return r(this,E).filter(e).length}get pending(){return r(this,x)}get isPaused(){return r(this,T)}}N=new WeakMap,S=new WeakMap,O=new WeakMap,R=new WeakMap,z=new WeakMap,M=new WeakMap,I=new WeakMap,L=new WeakMap,E=new WeakMap,V=new WeakMap,x=new WeakMap,q=new WeakMap,T=new WeakMap,Y=new WeakMap,U=new WeakSet,he=function(){return r(this,S)||r(this,O)<r(this,R)},W=new WeakSet,fe=function(){return r(this,x)<r(this,q)},X=new WeakSet,de=function(){G(this,x)._--,g(this,D,H).call(this),this.emit("next")},Z=new WeakSet,ve=function(){g(this,B,ne).call(this),g(this,Q,re).call(this),v(this,L,void 0)},j=new WeakSet,me=function(){const e=Date.now();if(r(this,I)===void 0){const n=r(this,M)-e;if(n<0)v(this,O,r(this,N)?r(this,x):0);else return r(this,L)===void 0&&v(this,L,setTimeout(()=>{g(this,Z,ve).call(this)},n)),!0}return!1},D=new WeakSet,H=function(){if(r(this,E).size===0)return r(this,I)&&clearInterval(r(this,I)),v(this,I,void 0),this.emit("empty"),r(this,x)===0&&this.emit("idle"),!1;if(!r(this,T)){const e=!r(this,j,me);if(r(this,U,he)&&r(this,W,fe)){const n=r(this,E).dequeue();return n?(this.emit("active"),n(),e&&g(this,Q,re).call(this),!0):!1}}return!1},Q=new WeakSet,re=function(){r(this,S)||r(this,I)!==void 0||(v(this,I,setInterval(()=>{g(this,B,ne).call(this)},r(this,z))),v(this,M,Date.now()+r(this,z)))},B=new WeakSet,ne=function(){r(this,O)===0&&r(this,x)===0&&r(this,I)&&(clearInterval(r(this,I)),v(this,I,void 0)),v(this,O,r(this,N)?r(this,x):0),g(this,$,J).call(this)},$=new WeakSet,J=function(){for(;g(this,D,H).call(this););},ee=new WeakSet,pe=async function(e){return new Promise((n,l)=>{e.addEventListener("abort",()=>{l(e.reason)},{once:!0})})},k=new WeakSet,K=async function(e,n){return new Promise(l=>{const w=()=>{n&&!n()||(this.off(e,w),l())};this.on(e,w)})};const Fe=Ie("pgcr",()=>{const s=xe(),t=Te(),e=Oe(),n=new De({concurrency:8}),l=ie(!1);n.on("idle",()=>l.value=!0);const w=()=>{p.value=0,n.clear(),s.clear()},p=ie(0);return{clear:w,fetchReport:c=>{const a=async()=>{p.value++;const i=await Ce(c,t);s.insertEncounters(i)};n.add(()=>a(),{signal:e.signal}),l.value=!1},fetchedCount:ae(p),idle:ae(l)}});export{Fe as a,Oe as b,Te as u};
